"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/aws4fetch";
exports.ids = ["vendor-chunks/aws4fetch"];
exports.modules = {

/***/ "(rsc)/./node_modules/aws4fetch/dist/aws4fetch.esm.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/aws4fetch/dist/aws4fetch.esm.mjs ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AwsClient: () => (/* binding */ AwsClient),\n/* harmony export */   AwsV4Signer: () => (/* binding */ AwsV4Signer)\n/* harmony export */ });\n/**\n * @license MIT <https://opensource.org/licenses/MIT>\n * @copyright Michael Hart 2024\n */\nconst encoder = new TextEncoder();\nconst HOST_SERVICES = {\n  appstream2: 'appstream',\n  cloudhsmv2: 'cloudhsm',\n  email: 'ses',\n  marketplace: 'aws-marketplace',\n  mobile: 'AWSMobileHubService',\n  pinpoint: 'mobiletargeting',\n  queue: 'sqs',\n  'git-codecommit': 'codecommit',\n  'mturk-requester-sandbox': 'mturk-requester',\n  'personalize-runtime': 'personalize',\n};\nconst UNSIGNABLE_HEADERS = new Set([\n  'authorization',\n  'content-type',\n  'content-length',\n  'user-agent',\n  'presigned-expires',\n  'expect',\n  'x-amzn-trace-id',\n  'range',\n  'connection',\n]);\nclass AwsClient {\n  constructor({ accessKeyId, secretAccessKey, sessionToken, service, region, cache, retries, initRetryMs }) {\n    if (accessKeyId == null) throw new TypeError('accessKeyId is a required option')\n    if (secretAccessKey == null) throw new TypeError('secretAccessKey is a required option')\n    this.accessKeyId = accessKeyId;\n    this.secretAccessKey = secretAccessKey;\n    this.sessionToken = sessionToken;\n    this.service = service;\n    this.region = region;\n    this.cache = cache || new Map();\n    this.retries = retries != null ? retries : 10;\n    this.initRetryMs = initRetryMs || 50;\n  }\n  async sign(input, init) {\n    if (input instanceof Request) {\n      const { method, url, headers, body } = input;\n      init = Object.assign({ method, url, headers }, init);\n      if (init.body == null && headers.has('Content-Type')) {\n        init.body = body != null && headers.has('X-Amz-Content-Sha256') ? body : await input.clone().arrayBuffer();\n      }\n      input = url;\n    }\n    const signer = new AwsV4Signer(Object.assign({ url: input.toString() }, init, this, init && init.aws));\n    const signed = Object.assign({}, init, await signer.sign());\n    delete signed.aws;\n    try {\n      return new Request(signed.url.toString(), signed)\n    } catch (e) {\n      if (e instanceof TypeError) {\n        return new Request(signed.url.toString(), Object.assign({ duplex: 'half' }, signed))\n      }\n      throw e\n    }\n  }\n  async fetch(input, init) {\n    for (let i = 0; i <= this.retries; i++) {\n      const fetched = fetch(await this.sign(input, init));\n      if (i === this.retries) {\n        return fetched\n      }\n      const res = await fetched;\n      if (res.status < 500 && res.status !== 429) {\n        return res\n      }\n      await new Promise(resolve => setTimeout(resolve, Math.random() * this.initRetryMs * Math.pow(2, i)));\n    }\n    throw new Error('An unknown error occurred, ensure retries is not negative')\n  }\n}\nclass AwsV4Signer {\n  constructor({ method, url, headers, body, accessKeyId, secretAccessKey, sessionToken, service, region, cache, datetime, signQuery, appendSessionToken, allHeaders, singleEncode }) {\n    if (url == null) throw new TypeError('url is a required option')\n    if (accessKeyId == null) throw new TypeError('accessKeyId is a required option')\n    if (secretAccessKey == null) throw new TypeError('secretAccessKey is a required option')\n    this.method = method || (body ? 'POST' : 'GET');\n    this.url = new URL(url);\n    this.headers = new Headers(headers || {});\n    this.body = body;\n    this.accessKeyId = accessKeyId;\n    this.secretAccessKey = secretAccessKey;\n    this.sessionToken = sessionToken;\n    let guessedService, guessedRegion;\n    if (!service || !region) {\n[guessedService, guessedRegion] = guessServiceRegion(this.url, this.headers);\n    }\n    this.service = service || guessedService || '';\n    this.region = region || guessedRegion || 'us-east-1';\n    this.cache = cache || new Map();\n    this.datetime = datetime || new Date().toISOString().replace(/[:-]|\\.\\d{3}/g, '');\n    this.signQuery = signQuery;\n    this.appendSessionToken = appendSessionToken || this.service === 'iotdevicegateway';\n    this.headers.delete('Host');\n    if (this.service === 's3' && !this.signQuery && !this.headers.has('X-Amz-Content-Sha256')) {\n      this.headers.set('X-Amz-Content-Sha256', 'UNSIGNED-PAYLOAD');\n    }\n    const params = this.signQuery ? this.url.searchParams : this.headers;\n    params.set('X-Amz-Date', this.datetime);\n    if (this.sessionToken && !this.appendSessionToken) {\n      params.set('X-Amz-Security-Token', this.sessionToken);\n    }\n    this.signableHeaders = ['host', ...this.headers.keys()]\n      .filter(header => allHeaders || !UNSIGNABLE_HEADERS.has(header))\n      .sort();\n    this.signedHeaders = this.signableHeaders.join(';');\n    this.canonicalHeaders = this.signableHeaders\n      .map(header => header + ':' + (header === 'host' ? this.url.host : (this.headers.get(header) || '').replace(/\\s+/g, ' ')))\n      .join('\\n');\n    this.credentialString = [this.datetime.slice(0, 8), this.region, this.service, 'aws4_request'].join('/');\n    if (this.signQuery) {\n      if (this.service === 's3' && !params.has('X-Amz-Expires')) {\n        params.set('X-Amz-Expires', '86400');\n      }\n      params.set('X-Amz-Algorithm', 'AWS4-HMAC-SHA256');\n      params.set('X-Amz-Credential', this.accessKeyId + '/' + this.credentialString);\n      params.set('X-Amz-SignedHeaders', this.signedHeaders);\n    }\n    if (this.service === 's3') {\n      try {\n        this.encodedPath = decodeURIComponent(this.url.pathname.replace(/\\+/g, ' '));\n      } catch (e) {\n        this.encodedPath = this.url.pathname;\n      }\n    } else {\n      this.encodedPath = this.url.pathname.replace(/\\/+/g, '/');\n    }\n    if (!singleEncode) {\n      this.encodedPath = encodeURIComponent(this.encodedPath).replace(/%2F/g, '/');\n    }\n    this.encodedPath = encodeRfc3986(this.encodedPath);\n    const seenKeys = new Set();\n    this.encodedSearch = [...this.url.searchParams]\n      .filter(([k]) => {\n        if (!k) return false\n        if (this.service === 's3') {\n          if (seenKeys.has(k)) return false\n          seenKeys.add(k);\n        }\n        return true\n      })\n      .map(pair => pair.map(p => encodeRfc3986(encodeURIComponent(p))))\n      .sort(([k1, v1], [k2, v2]) => k1 < k2 ? -1 : k1 > k2 ? 1 : v1 < v2 ? -1 : v1 > v2 ? 1 : 0)\n      .map(pair => pair.join('='))\n      .join('&');\n  }\n  async sign() {\n    if (this.signQuery) {\n      this.url.searchParams.set('X-Amz-Signature', await this.signature());\n      if (this.sessionToken && this.appendSessionToken) {\n        this.url.searchParams.set('X-Amz-Security-Token', this.sessionToken);\n      }\n    } else {\n      this.headers.set('Authorization', await this.authHeader());\n    }\n    return {\n      method: this.method,\n      url: this.url,\n      headers: this.headers,\n      body: this.body,\n    }\n  }\n  async authHeader() {\n    return [\n      'AWS4-HMAC-SHA256 Credential=' + this.accessKeyId + '/' + this.credentialString,\n      'SignedHeaders=' + this.signedHeaders,\n      'Signature=' + (await this.signature()),\n    ].join(', ')\n  }\n  async signature() {\n    const date = this.datetime.slice(0, 8);\n    const cacheKey = [this.secretAccessKey, date, this.region, this.service].join();\n    let kCredentials = this.cache.get(cacheKey);\n    if (!kCredentials) {\n      const kDate = await hmac('AWS4' + this.secretAccessKey, date);\n      const kRegion = await hmac(kDate, this.region);\n      const kService = await hmac(kRegion, this.service);\n      kCredentials = await hmac(kService, 'aws4_request');\n      this.cache.set(cacheKey, kCredentials);\n    }\n    return buf2hex(await hmac(kCredentials, await this.stringToSign()))\n  }\n  async stringToSign() {\n    return [\n      'AWS4-HMAC-SHA256',\n      this.datetime,\n      this.credentialString,\n      buf2hex(await hash(await this.canonicalString())),\n    ].join('\\n')\n  }\n  async canonicalString() {\n    return [\n      this.method.toUpperCase(),\n      this.encodedPath,\n      this.encodedSearch,\n      this.canonicalHeaders + '\\n',\n      this.signedHeaders,\n      await this.hexBodyHash(),\n    ].join('\\n')\n  }\n  async hexBodyHash() {\n    let hashHeader = this.headers.get('X-Amz-Content-Sha256') || (this.service === 's3' && this.signQuery ? 'UNSIGNED-PAYLOAD' : null);\n    if (hashHeader == null) {\n      if (this.body && typeof this.body !== 'string' && !('byteLength' in this.body)) {\n        throw new Error('body must be a string, ArrayBuffer or ArrayBufferView, unless you include the X-Amz-Content-Sha256 header')\n      }\n      hashHeader = buf2hex(await hash(this.body || ''));\n    }\n    return hashHeader\n  }\n}\nasync function hmac(key, string) {\n  const cryptoKey = await crypto.subtle.importKey(\n    'raw',\n    typeof key === 'string' ? encoder.encode(key) : key,\n    { name: 'HMAC', hash: { name: 'SHA-256' } },\n    false,\n    ['sign'],\n  );\n  return crypto.subtle.sign('HMAC', cryptoKey, encoder.encode(string))\n}\nasync function hash(content) {\n  return crypto.subtle.digest('SHA-256', typeof content === 'string' ? encoder.encode(content) : content)\n}\nconst HEX_CHARS = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];\nfunction buf2hex(arrayBuffer) {\n  const buffer = new Uint8Array(arrayBuffer);\n  let out = '';\n  for (let idx = 0; idx < buffer.length; idx++) {\n    const n = buffer[idx];\n    out += HEX_CHARS[(n >>> 4) & 0xF];\n    out += HEX_CHARS[n & 0xF];\n  }\n  return out\n}\nfunction encodeRfc3986(urlEncodedStr) {\n  return urlEncodedStr.replace(/[!'()*]/g, c => '%' + c.charCodeAt(0).toString(16).toUpperCase())\n}\nfunction guessServiceRegion(url, headers) {\n  const { hostname, pathname } = url;\n  if (hostname.endsWith('.on.aws')) {\n    const match = hostname.match(/^[^.]{1,63}\\.lambda-url\\.([^.]{1,63})\\.on\\.aws$/);\n    return match != null ? ['lambda', match[1] || ''] : ['', '']\n  }\n  if (hostname.endsWith('.r2.cloudflarestorage.com')) {\n    return ['s3', 'auto']\n  }\n  if (hostname.endsWith('.backblazeb2.com')) {\n    const match = hostname.match(/^(?:[^.]{1,63}\\.)?s3\\.([^.]{1,63})\\.backblazeb2\\.com$/);\n    return match != null ? ['s3', match[1] || ''] : ['', '']\n  }\n  const match = hostname.replace('dualstack.', '').match(/([^.]{1,63})\\.(?:([^.]{0,63})\\.)?amazonaws\\.com(?:\\.cn)?$/);\n  let service = (match && match[1]) || '';\n  let region = match && match[2];\n  if (region === 'us-gov') {\n    region = 'us-gov-west-1';\n  } else if (region === 's3' || region === 's3-accelerate') {\n    region = 'us-east-1';\n    service = 's3';\n  } else if (service === 'iot') {\n    if (hostname.startsWith('iot.')) {\n      service = 'execute-api';\n    } else if (hostname.startsWith('data.jobs.iot.')) {\n      service = 'iot-jobs-data';\n    } else {\n      service = pathname === '/mqtt' ? 'iotdevicegateway' : 'iotdata';\n    }\n  } else if (service === 'autoscaling') {\n    const targetPrefix = (headers.get('X-Amz-Target') || '').split('.')[0];\n    if (targetPrefix === 'AnyScaleFrontendService') {\n      service = 'application-autoscaling';\n    } else if (targetPrefix === 'AnyScaleScalingPlannerFrontendService') {\n      service = 'autoscaling-plans';\n    }\n  } else if (region == null && service.startsWith('s3-')) {\n    region = service.slice(3).replace(/^fips-|^external-1/, '');\n    service = 's3';\n  } else if (service.endsWith('-fips')) {\n    service = service.slice(0, -5);\n  } else if (region && /-\\d$/.test(service) && !/-\\d$/.test(region)) {\n[service, region] = [region, service];\n  }\n  return [HOST_SERVICES[service] || service, region || '']\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYXdzNGZldGNoL2Rpc3QvYXdzNGZldGNoLmVzbS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDBGQUEwRjtBQUMxRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsNkJBQTZCO0FBQzNDLDZCQUE2QixzQkFBc0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCx1QkFBdUI7QUFDMUUsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLGtFQUFrRSxnQkFBZ0I7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtS0FBbUs7QUFDbkw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLEVBQUU7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxzQkFBc0IsbUJBQW1CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHFCQUFxQjtBQUMvQjtBQUNBLHdDQUF3QyxLQUFLLG9CQUFvQixLQUFLO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxLQUFLLGNBQWMsS0FBSztBQUNuRTtBQUNBO0FBQ0EsZ0VBQWdFLEtBQUssWUFBWSxLQUFLO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRWtDIiwic291cmNlcyI6WyIvVXNlcnMvbWF0c3Vtb19hbmQvc3BlY2lmaWNhdGlvbi1kb2N1bWVudC1hZ2VudC9ub2RlX21vZHVsZXMvYXdzNGZldGNoL2Rpc3QvYXdzNGZldGNoLmVzbS5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZSBNSVQgPGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUPlxuICogQGNvcHlyaWdodCBNaWNoYWVsIEhhcnQgMjAyNFxuICovXG5jb25zdCBlbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG5jb25zdCBIT1NUX1NFUlZJQ0VTID0ge1xuICBhcHBzdHJlYW0yOiAnYXBwc3RyZWFtJyxcbiAgY2xvdWRoc212MjogJ2Nsb3VkaHNtJyxcbiAgZW1haWw6ICdzZXMnLFxuICBtYXJrZXRwbGFjZTogJ2F3cy1tYXJrZXRwbGFjZScsXG4gIG1vYmlsZTogJ0FXU01vYmlsZUh1YlNlcnZpY2UnLFxuICBwaW5wb2ludDogJ21vYmlsZXRhcmdldGluZycsXG4gIHF1ZXVlOiAnc3FzJyxcbiAgJ2dpdC1jb2RlY29tbWl0JzogJ2NvZGVjb21taXQnLFxuICAnbXR1cmstcmVxdWVzdGVyLXNhbmRib3gnOiAnbXR1cmstcmVxdWVzdGVyJyxcbiAgJ3BlcnNvbmFsaXplLXJ1bnRpbWUnOiAncGVyc29uYWxpemUnLFxufTtcbmNvbnN0IFVOU0lHTkFCTEVfSEVBREVSUyA9IG5ldyBTZXQoW1xuICAnYXV0aG9yaXphdGlvbicsXG4gICdjb250ZW50LXR5cGUnLFxuICAnY29udGVudC1sZW5ndGgnLFxuICAndXNlci1hZ2VudCcsXG4gICdwcmVzaWduZWQtZXhwaXJlcycsXG4gICdleHBlY3QnLFxuICAneC1hbXpuLXRyYWNlLWlkJyxcbiAgJ3JhbmdlJyxcbiAgJ2Nvbm5lY3Rpb24nLFxuXSk7XG5jbGFzcyBBd3NDbGllbnQge1xuICBjb25zdHJ1Y3Rvcih7IGFjY2Vzc0tleUlkLCBzZWNyZXRBY2Nlc3NLZXksIHNlc3Npb25Ub2tlbiwgc2VydmljZSwgcmVnaW9uLCBjYWNoZSwgcmV0cmllcywgaW5pdFJldHJ5TXMgfSkge1xuICAgIGlmIChhY2Nlc3NLZXlJZCA9PSBudWxsKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdhY2Nlc3NLZXlJZCBpcyBhIHJlcXVpcmVkIG9wdGlvbicpXG4gICAgaWYgKHNlY3JldEFjY2Vzc0tleSA9PSBudWxsKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdzZWNyZXRBY2Nlc3NLZXkgaXMgYSByZXF1aXJlZCBvcHRpb24nKVxuICAgIHRoaXMuYWNjZXNzS2V5SWQgPSBhY2Nlc3NLZXlJZDtcbiAgICB0aGlzLnNlY3JldEFjY2Vzc0tleSA9IHNlY3JldEFjY2Vzc0tleTtcbiAgICB0aGlzLnNlc3Npb25Ub2tlbiA9IHNlc3Npb25Ub2tlbjtcbiAgICB0aGlzLnNlcnZpY2UgPSBzZXJ2aWNlO1xuICAgIHRoaXMucmVnaW9uID0gcmVnaW9uO1xuICAgIHRoaXMuY2FjaGUgPSBjYWNoZSB8fCBuZXcgTWFwKCk7XG4gICAgdGhpcy5yZXRyaWVzID0gcmV0cmllcyAhPSBudWxsID8gcmV0cmllcyA6IDEwO1xuICAgIHRoaXMuaW5pdFJldHJ5TXMgPSBpbml0UmV0cnlNcyB8fCA1MDtcbiAgfVxuICBhc3luYyBzaWduKGlucHV0LCBpbml0KSB7XG4gICAgaWYgKGlucHV0IGluc3RhbmNlb2YgUmVxdWVzdCkge1xuICAgICAgY29uc3QgeyBtZXRob2QsIHVybCwgaGVhZGVycywgYm9keSB9ID0gaW5wdXQ7XG4gICAgICBpbml0ID0gT2JqZWN0LmFzc2lnbih7IG1ldGhvZCwgdXJsLCBoZWFkZXJzIH0sIGluaXQpO1xuICAgICAgaWYgKGluaXQuYm9keSA9PSBudWxsICYmIGhlYWRlcnMuaGFzKCdDb250ZW50LVR5cGUnKSkge1xuICAgICAgICBpbml0LmJvZHkgPSBib2R5ICE9IG51bGwgJiYgaGVhZGVycy5oYXMoJ1gtQW16LUNvbnRlbnQtU2hhMjU2JykgPyBib2R5IDogYXdhaXQgaW5wdXQuY2xvbmUoKS5hcnJheUJ1ZmZlcigpO1xuICAgICAgfVxuICAgICAgaW5wdXQgPSB1cmw7XG4gICAgfVxuICAgIGNvbnN0IHNpZ25lciA9IG5ldyBBd3NWNFNpZ25lcihPYmplY3QuYXNzaWduKHsgdXJsOiBpbnB1dC50b1N0cmluZygpIH0sIGluaXQsIHRoaXMsIGluaXQgJiYgaW5pdC5hd3MpKTtcbiAgICBjb25zdCBzaWduZWQgPSBPYmplY3QuYXNzaWduKHt9LCBpbml0LCBhd2FpdCBzaWduZXIuc2lnbigpKTtcbiAgICBkZWxldGUgc2lnbmVkLmF3cztcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIG5ldyBSZXF1ZXN0KHNpZ25lZC51cmwudG9TdHJpbmcoKSwgc2lnbmVkKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChlIGluc3RhbmNlb2YgVHlwZUVycm9yKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVxdWVzdChzaWduZWQudXJsLnRvU3RyaW5nKCksIE9iamVjdC5hc3NpZ24oeyBkdXBsZXg6ICdoYWxmJyB9LCBzaWduZWQpKVxuICAgICAgfVxuICAgICAgdGhyb3cgZVxuICAgIH1cbiAgfVxuICBhc3luYyBmZXRjaChpbnB1dCwgaW5pdCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IHRoaXMucmV0cmllczsgaSsrKSB7XG4gICAgICBjb25zdCBmZXRjaGVkID0gZmV0Y2goYXdhaXQgdGhpcy5zaWduKGlucHV0LCBpbml0KSk7XG4gICAgICBpZiAoaSA9PT0gdGhpcy5yZXRyaWVzKSB7XG4gICAgICAgIHJldHVybiBmZXRjaGVkXG4gICAgICB9XG4gICAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaGVkO1xuICAgICAgaWYgKHJlcy5zdGF0dXMgPCA1MDAgJiYgcmVzLnN0YXR1cyAhPT0gNDI5KSB7XG4gICAgICAgIHJldHVybiByZXNcbiAgICAgIH1cbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCBNYXRoLnJhbmRvbSgpICogdGhpcy5pbml0UmV0cnlNcyAqIE1hdGgucG93KDIsIGkpKSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignQW4gdW5rbm93biBlcnJvciBvY2N1cnJlZCwgZW5zdXJlIHJldHJpZXMgaXMgbm90IG5lZ2F0aXZlJylcbiAgfVxufVxuY2xhc3MgQXdzVjRTaWduZXIge1xuICBjb25zdHJ1Y3Rvcih7IG1ldGhvZCwgdXJsLCBoZWFkZXJzLCBib2R5LCBhY2Nlc3NLZXlJZCwgc2VjcmV0QWNjZXNzS2V5LCBzZXNzaW9uVG9rZW4sIHNlcnZpY2UsIHJlZ2lvbiwgY2FjaGUsIGRhdGV0aW1lLCBzaWduUXVlcnksIGFwcGVuZFNlc3Npb25Ub2tlbiwgYWxsSGVhZGVycywgc2luZ2xlRW5jb2RlIH0pIHtcbiAgICBpZiAodXJsID09IG51bGwpIHRocm93IG5ldyBUeXBlRXJyb3IoJ3VybCBpcyBhIHJlcXVpcmVkIG9wdGlvbicpXG4gICAgaWYgKGFjY2Vzc0tleUlkID09IG51bGwpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2FjY2Vzc0tleUlkIGlzIGEgcmVxdWlyZWQgb3B0aW9uJylcbiAgICBpZiAoc2VjcmV0QWNjZXNzS2V5ID09IG51bGwpIHRocm93IG5ldyBUeXBlRXJyb3IoJ3NlY3JldEFjY2Vzc0tleSBpcyBhIHJlcXVpcmVkIG9wdGlvbicpXG4gICAgdGhpcy5tZXRob2QgPSBtZXRob2QgfHwgKGJvZHkgPyAnUE9TVCcgOiAnR0VUJyk7XG4gICAgdGhpcy51cmwgPSBuZXcgVVJMKHVybCk7XG4gICAgdGhpcy5oZWFkZXJzID0gbmV3IEhlYWRlcnMoaGVhZGVycyB8fCB7fSk7XG4gICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICB0aGlzLmFjY2Vzc0tleUlkID0gYWNjZXNzS2V5SWQ7XG4gICAgdGhpcy5zZWNyZXRBY2Nlc3NLZXkgPSBzZWNyZXRBY2Nlc3NLZXk7XG4gICAgdGhpcy5zZXNzaW9uVG9rZW4gPSBzZXNzaW9uVG9rZW47XG4gICAgbGV0IGd1ZXNzZWRTZXJ2aWNlLCBndWVzc2VkUmVnaW9uO1xuICAgIGlmICghc2VydmljZSB8fCAhcmVnaW9uKSB7XG5bZ3Vlc3NlZFNlcnZpY2UsIGd1ZXNzZWRSZWdpb25dID0gZ3Vlc3NTZXJ2aWNlUmVnaW9uKHRoaXMudXJsLCB0aGlzLmhlYWRlcnMpO1xuICAgIH1cbiAgICB0aGlzLnNlcnZpY2UgPSBzZXJ2aWNlIHx8IGd1ZXNzZWRTZXJ2aWNlIHx8ICcnO1xuICAgIHRoaXMucmVnaW9uID0gcmVnaW9uIHx8IGd1ZXNzZWRSZWdpb24gfHwgJ3VzLWVhc3QtMSc7XG4gICAgdGhpcy5jYWNoZSA9IGNhY2hlIHx8IG5ldyBNYXAoKTtcbiAgICB0aGlzLmRhdGV0aW1lID0gZGF0ZXRpbWUgfHwgbmV3IERhdGUoKS50b0lTT1N0cmluZygpLnJlcGxhY2UoL1s6LV18XFwuXFxkezN9L2csICcnKTtcbiAgICB0aGlzLnNpZ25RdWVyeSA9IHNpZ25RdWVyeTtcbiAgICB0aGlzLmFwcGVuZFNlc3Npb25Ub2tlbiA9IGFwcGVuZFNlc3Npb25Ub2tlbiB8fCB0aGlzLnNlcnZpY2UgPT09ICdpb3RkZXZpY2VnYXRld2F5JztcbiAgICB0aGlzLmhlYWRlcnMuZGVsZXRlKCdIb3N0Jyk7XG4gICAgaWYgKHRoaXMuc2VydmljZSA9PT0gJ3MzJyAmJiAhdGhpcy5zaWduUXVlcnkgJiYgIXRoaXMuaGVhZGVycy5oYXMoJ1gtQW16LUNvbnRlbnQtU2hhMjU2JykpIHtcbiAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ1gtQW16LUNvbnRlbnQtU2hhMjU2JywgJ1VOU0lHTkVELVBBWUxPQUQnKTtcbiAgICB9XG4gICAgY29uc3QgcGFyYW1zID0gdGhpcy5zaWduUXVlcnkgPyB0aGlzLnVybC5zZWFyY2hQYXJhbXMgOiB0aGlzLmhlYWRlcnM7XG4gICAgcGFyYW1zLnNldCgnWC1BbXotRGF0ZScsIHRoaXMuZGF0ZXRpbWUpO1xuICAgIGlmICh0aGlzLnNlc3Npb25Ub2tlbiAmJiAhdGhpcy5hcHBlbmRTZXNzaW9uVG9rZW4pIHtcbiAgICAgIHBhcmFtcy5zZXQoJ1gtQW16LVNlY3VyaXR5LVRva2VuJywgdGhpcy5zZXNzaW9uVG9rZW4pO1xuICAgIH1cbiAgICB0aGlzLnNpZ25hYmxlSGVhZGVycyA9IFsnaG9zdCcsIC4uLnRoaXMuaGVhZGVycy5rZXlzKCldXG4gICAgICAuZmlsdGVyKGhlYWRlciA9PiBhbGxIZWFkZXJzIHx8ICFVTlNJR05BQkxFX0hFQURFUlMuaGFzKGhlYWRlcikpXG4gICAgICAuc29ydCgpO1xuICAgIHRoaXMuc2lnbmVkSGVhZGVycyA9IHRoaXMuc2lnbmFibGVIZWFkZXJzLmpvaW4oJzsnKTtcbiAgICB0aGlzLmNhbm9uaWNhbEhlYWRlcnMgPSB0aGlzLnNpZ25hYmxlSGVhZGVyc1xuICAgICAgLm1hcChoZWFkZXIgPT4gaGVhZGVyICsgJzonICsgKGhlYWRlciA9PT0gJ2hvc3QnID8gdGhpcy51cmwuaG9zdCA6ICh0aGlzLmhlYWRlcnMuZ2V0KGhlYWRlcikgfHwgJycpLnJlcGxhY2UoL1xccysvZywgJyAnKSkpXG4gICAgICAuam9pbignXFxuJyk7XG4gICAgdGhpcy5jcmVkZW50aWFsU3RyaW5nID0gW3RoaXMuZGF0ZXRpbWUuc2xpY2UoMCwgOCksIHRoaXMucmVnaW9uLCB0aGlzLnNlcnZpY2UsICdhd3M0X3JlcXVlc3QnXS5qb2luKCcvJyk7XG4gICAgaWYgKHRoaXMuc2lnblF1ZXJ5KSB7XG4gICAgICBpZiAodGhpcy5zZXJ2aWNlID09PSAnczMnICYmICFwYXJhbXMuaGFzKCdYLUFtei1FeHBpcmVzJykpIHtcbiAgICAgICAgcGFyYW1zLnNldCgnWC1BbXotRXhwaXJlcycsICc4NjQwMCcpO1xuICAgICAgfVxuICAgICAgcGFyYW1zLnNldCgnWC1BbXotQWxnb3JpdGhtJywgJ0FXUzQtSE1BQy1TSEEyNTYnKTtcbiAgICAgIHBhcmFtcy5zZXQoJ1gtQW16LUNyZWRlbnRpYWwnLCB0aGlzLmFjY2Vzc0tleUlkICsgJy8nICsgdGhpcy5jcmVkZW50aWFsU3RyaW5nKTtcbiAgICAgIHBhcmFtcy5zZXQoJ1gtQW16LVNpZ25lZEhlYWRlcnMnLCB0aGlzLnNpZ25lZEhlYWRlcnMpO1xuICAgIH1cbiAgICBpZiAodGhpcy5zZXJ2aWNlID09PSAnczMnKSB7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLmVuY29kZWRQYXRoID0gZGVjb2RlVVJJQ29tcG9uZW50KHRoaXMudXJsLnBhdGhuYW1lLnJlcGxhY2UoL1xcKy9nLCAnICcpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhpcy5lbmNvZGVkUGF0aCA9IHRoaXMudXJsLnBhdGhuYW1lO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmVuY29kZWRQYXRoID0gdGhpcy51cmwucGF0aG5hbWUucmVwbGFjZSgvXFwvKy9nLCAnLycpO1xuICAgIH1cbiAgICBpZiAoIXNpbmdsZUVuY29kZSkge1xuICAgICAgdGhpcy5lbmNvZGVkUGF0aCA9IGVuY29kZVVSSUNvbXBvbmVudCh0aGlzLmVuY29kZWRQYXRoKS5yZXBsYWNlKC8lMkYvZywgJy8nKTtcbiAgICB9XG4gICAgdGhpcy5lbmNvZGVkUGF0aCA9IGVuY29kZVJmYzM5ODYodGhpcy5lbmNvZGVkUGF0aCk7XG4gICAgY29uc3Qgc2VlbktleXMgPSBuZXcgU2V0KCk7XG4gICAgdGhpcy5lbmNvZGVkU2VhcmNoID0gWy4uLnRoaXMudXJsLnNlYXJjaFBhcmFtc11cbiAgICAgIC5maWx0ZXIoKFtrXSkgPT4ge1xuICAgICAgICBpZiAoIWspIHJldHVybiBmYWxzZVxuICAgICAgICBpZiAodGhpcy5zZXJ2aWNlID09PSAnczMnKSB7XG4gICAgICAgICAgaWYgKHNlZW5LZXlzLmhhcyhrKSkgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgc2VlbktleXMuYWRkKGspO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9KVxuICAgICAgLm1hcChwYWlyID0+IHBhaXIubWFwKHAgPT4gZW5jb2RlUmZjMzk4NihlbmNvZGVVUklDb21wb25lbnQocCkpKSlcbiAgICAgIC5zb3J0KChbazEsIHYxXSwgW2syLCB2Ml0pID0+IGsxIDwgazIgPyAtMSA6IGsxID4gazIgPyAxIDogdjEgPCB2MiA/IC0xIDogdjEgPiB2MiA/IDEgOiAwKVxuICAgICAgLm1hcChwYWlyID0+IHBhaXIuam9pbignPScpKVxuICAgICAgLmpvaW4oJyYnKTtcbiAgfVxuICBhc3luYyBzaWduKCkge1xuICAgIGlmICh0aGlzLnNpZ25RdWVyeSkge1xuICAgICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLnNldCgnWC1BbXotU2lnbmF0dXJlJywgYXdhaXQgdGhpcy5zaWduYXR1cmUoKSk7XG4gICAgICBpZiAodGhpcy5zZXNzaW9uVG9rZW4gJiYgdGhpcy5hcHBlbmRTZXNzaW9uVG9rZW4pIHtcbiAgICAgICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLnNldCgnWC1BbXotU2VjdXJpdHktVG9rZW4nLCB0aGlzLnNlc3Npb25Ub2tlbik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ0F1dGhvcml6YXRpb24nLCBhd2FpdCB0aGlzLmF1dGhIZWFkZXIoKSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBtZXRob2Q6IHRoaXMubWV0aG9kLFxuICAgICAgdXJsOiB0aGlzLnVybCxcbiAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgIGJvZHk6IHRoaXMuYm9keSxcbiAgICB9XG4gIH1cbiAgYXN5bmMgYXV0aEhlYWRlcigpIHtcbiAgICByZXR1cm4gW1xuICAgICAgJ0FXUzQtSE1BQy1TSEEyNTYgQ3JlZGVudGlhbD0nICsgdGhpcy5hY2Nlc3NLZXlJZCArICcvJyArIHRoaXMuY3JlZGVudGlhbFN0cmluZyxcbiAgICAgICdTaWduZWRIZWFkZXJzPScgKyB0aGlzLnNpZ25lZEhlYWRlcnMsXG4gICAgICAnU2lnbmF0dXJlPScgKyAoYXdhaXQgdGhpcy5zaWduYXR1cmUoKSksXG4gICAgXS5qb2luKCcsICcpXG4gIH1cbiAgYXN5bmMgc2lnbmF0dXJlKCkge1xuICAgIGNvbnN0IGRhdGUgPSB0aGlzLmRhdGV0aW1lLnNsaWNlKDAsIDgpO1xuICAgIGNvbnN0IGNhY2hlS2V5ID0gW3RoaXMuc2VjcmV0QWNjZXNzS2V5LCBkYXRlLCB0aGlzLnJlZ2lvbiwgdGhpcy5zZXJ2aWNlXS5qb2luKCk7XG4gICAgbGV0IGtDcmVkZW50aWFscyA9IHRoaXMuY2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgICBpZiAoIWtDcmVkZW50aWFscykge1xuICAgICAgY29uc3Qga0RhdGUgPSBhd2FpdCBobWFjKCdBV1M0JyArIHRoaXMuc2VjcmV0QWNjZXNzS2V5LCBkYXRlKTtcbiAgICAgIGNvbnN0IGtSZWdpb24gPSBhd2FpdCBobWFjKGtEYXRlLCB0aGlzLnJlZ2lvbik7XG4gICAgICBjb25zdCBrU2VydmljZSA9IGF3YWl0IGhtYWMoa1JlZ2lvbiwgdGhpcy5zZXJ2aWNlKTtcbiAgICAgIGtDcmVkZW50aWFscyA9IGF3YWl0IGhtYWMoa1NlcnZpY2UsICdhd3M0X3JlcXVlc3QnKTtcbiAgICAgIHRoaXMuY2FjaGUuc2V0KGNhY2hlS2V5LCBrQ3JlZGVudGlhbHMpO1xuICAgIH1cbiAgICByZXR1cm4gYnVmMmhleChhd2FpdCBobWFjKGtDcmVkZW50aWFscywgYXdhaXQgdGhpcy5zdHJpbmdUb1NpZ24oKSkpXG4gIH1cbiAgYXN5bmMgc3RyaW5nVG9TaWduKCkge1xuICAgIHJldHVybiBbXG4gICAgICAnQVdTNC1ITUFDLVNIQTI1NicsXG4gICAgICB0aGlzLmRhdGV0aW1lLFxuICAgICAgdGhpcy5jcmVkZW50aWFsU3RyaW5nLFxuICAgICAgYnVmMmhleChhd2FpdCBoYXNoKGF3YWl0IHRoaXMuY2Fub25pY2FsU3RyaW5nKCkpKSxcbiAgICBdLmpvaW4oJ1xcbicpXG4gIH1cbiAgYXN5bmMgY2Fub25pY2FsU3RyaW5nKCkge1xuICAgIHJldHVybiBbXG4gICAgICB0aGlzLm1ldGhvZC50b1VwcGVyQ2FzZSgpLFxuICAgICAgdGhpcy5lbmNvZGVkUGF0aCxcbiAgICAgIHRoaXMuZW5jb2RlZFNlYXJjaCxcbiAgICAgIHRoaXMuY2Fub25pY2FsSGVhZGVycyArICdcXG4nLFxuICAgICAgdGhpcy5zaWduZWRIZWFkZXJzLFxuICAgICAgYXdhaXQgdGhpcy5oZXhCb2R5SGFzaCgpLFxuICAgIF0uam9pbignXFxuJylcbiAgfVxuICBhc3luYyBoZXhCb2R5SGFzaCgpIHtcbiAgICBsZXQgaGFzaEhlYWRlciA9IHRoaXMuaGVhZGVycy5nZXQoJ1gtQW16LUNvbnRlbnQtU2hhMjU2JykgfHwgKHRoaXMuc2VydmljZSA9PT0gJ3MzJyAmJiB0aGlzLnNpZ25RdWVyeSA/ICdVTlNJR05FRC1QQVlMT0FEJyA6IG51bGwpO1xuICAgIGlmIChoYXNoSGVhZGVyID09IG51bGwpIHtcbiAgICAgIGlmICh0aGlzLmJvZHkgJiYgdHlwZW9mIHRoaXMuYm9keSAhPT0gJ3N0cmluZycgJiYgISgnYnl0ZUxlbmd0aCcgaW4gdGhpcy5ib2R5KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JvZHkgbXVzdCBiZSBhIHN0cmluZywgQXJyYXlCdWZmZXIgb3IgQXJyYXlCdWZmZXJWaWV3LCB1bmxlc3MgeW91IGluY2x1ZGUgdGhlIFgtQW16LUNvbnRlbnQtU2hhMjU2IGhlYWRlcicpXG4gICAgICB9XG4gICAgICBoYXNoSGVhZGVyID0gYnVmMmhleChhd2FpdCBoYXNoKHRoaXMuYm9keSB8fCAnJykpO1xuICAgIH1cbiAgICByZXR1cm4gaGFzaEhlYWRlclxuICB9XG59XG5hc3luYyBmdW5jdGlvbiBobWFjKGtleSwgc3RyaW5nKSB7XG4gIGNvbnN0IGNyeXB0b0tleSA9IGF3YWl0IGNyeXB0by5zdWJ0bGUuaW1wb3J0S2V5KFxuICAgICdyYXcnLFxuICAgIHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnID8gZW5jb2Rlci5lbmNvZGUoa2V5KSA6IGtleSxcbiAgICB7IG5hbWU6ICdITUFDJywgaGFzaDogeyBuYW1lOiAnU0hBLTI1NicgfSB9LFxuICAgIGZhbHNlLFxuICAgIFsnc2lnbiddLFxuICApO1xuICByZXR1cm4gY3J5cHRvLnN1YnRsZS5zaWduKCdITUFDJywgY3J5cHRvS2V5LCBlbmNvZGVyLmVuY29kZShzdHJpbmcpKVxufVxuYXN5bmMgZnVuY3Rpb24gaGFzaChjb250ZW50KSB7XG4gIHJldHVybiBjcnlwdG8uc3VidGxlLmRpZ2VzdCgnU0hBLTI1NicsIHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJyA/IGVuY29kZXIuZW5jb2RlKGNvbnRlbnQpIDogY29udGVudClcbn1cbmNvbnN0IEhFWF9DSEFSUyA9IFsnMCcsICcxJywgJzInLCAnMycsICc0JywgJzUnLCAnNicsICc3JywgJzgnLCAnOScsICdhJywgJ2InLCAnYycsICdkJywgJ2UnLCAnZiddO1xuZnVuY3Rpb24gYnVmMmhleChhcnJheUJ1ZmZlcikge1xuICBjb25zdCBidWZmZXIgPSBuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlcik7XG4gIGxldCBvdXQgPSAnJztcbiAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgYnVmZmVyLmxlbmd0aDsgaWR4KyspIHtcbiAgICBjb25zdCBuID0gYnVmZmVyW2lkeF07XG4gICAgb3V0ICs9IEhFWF9DSEFSU1sobiA+Pj4gNCkgJiAweEZdO1xuICAgIG91dCArPSBIRVhfQ0hBUlNbbiAmIDB4Rl07XG4gIH1cbiAgcmV0dXJuIG91dFxufVxuZnVuY3Rpb24gZW5jb2RlUmZjMzk4Nih1cmxFbmNvZGVkU3RyKSB7XG4gIHJldHVybiB1cmxFbmNvZGVkU3RyLnJlcGxhY2UoL1shJygpKl0vZywgYyA9PiAnJScgKyBjLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkpXG59XG5mdW5jdGlvbiBndWVzc1NlcnZpY2VSZWdpb24odXJsLCBoZWFkZXJzKSB7XG4gIGNvbnN0IHsgaG9zdG5hbWUsIHBhdGhuYW1lIH0gPSB1cmw7XG4gIGlmIChob3N0bmFtZS5lbmRzV2l0aCgnLm9uLmF3cycpKSB7XG4gICAgY29uc3QgbWF0Y2ggPSBob3N0bmFtZS5tYXRjaCgvXlteLl17MSw2M31cXC5sYW1iZGEtdXJsXFwuKFteLl17MSw2M30pXFwub25cXC5hd3MkLyk7XG4gICAgcmV0dXJuIG1hdGNoICE9IG51bGwgPyBbJ2xhbWJkYScsIG1hdGNoWzFdIHx8ICcnXSA6IFsnJywgJyddXG4gIH1cbiAgaWYgKGhvc3RuYW1lLmVuZHNXaXRoKCcucjIuY2xvdWRmbGFyZXN0b3JhZ2UuY29tJykpIHtcbiAgICByZXR1cm4gWydzMycsICdhdXRvJ11cbiAgfVxuICBpZiAoaG9zdG5hbWUuZW5kc1dpdGgoJy5iYWNrYmxhemViMi5jb20nKSkge1xuICAgIGNvbnN0IG1hdGNoID0gaG9zdG5hbWUubWF0Y2goL14oPzpbXi5dezEsNjN9XFwuKT9zM1xcLihbXi5dezEsNjN9KVxcLmJhY2tibGF6ZWIyXFwuY29tJC8pO1xuICAgIHJldHVybiBtYXRjaCAhPSBudWxsID8gWydzMycsIG1hdGNoWzFdIHx8ICcnXSA6IFsnJywgJyddXG4gIH1cbiAgY29uc3QgbWF0Y2ggPSBob3N0bmFtZS5yZXBsYWNlKCdkdWFsc3RhY2suJywgJycpLm1hdGNoKC8oW14uXXsxLDYzfSlcXC4oPzooW14uXXswLDYzfSlcXC4pP2FtYXpvbmF3c1xcLmNvbSg/OlxcLmNuKT8kLyk7XG4gIGxldCBzZXJ2aWNlID0gKG1hdGNoICYmIG1hdGNoWzFdKSB8fCAnJztcbiAgbGV0IHJlZ2lvbiA9IG1hdGNoICYmIG1hdGNoWzJdO1xuICBpZiAocmVnaW9uID09PSAndXMtZ292Jykge1xuICAgIHJlZ2lvbiA9ICd1cy1nb3Ytd2VzdC0xJztcbiAgfSBlbHNlIGlmIChyZWdpb24gPT09ICdzMycgfHwgcmVnaW9uID09PSAnczMtYWNjZWxlcmF0ZScpIHtcbiAgICByZWdpb24gPSAndXMtZWFzdC0xJztcbiAgICBzZXJ2aWNlID0gJ3MzJztcbiAgfSBlbHNlIGlmIChzZXJ2aWNlID09PSAnaW90Jykge1xuICAgIGlmIChob3N0bmFtZS5zdGFydHNXaXRoKCdpb3QuJykpIHtcbiAgICAgIHNlcnZpY2UgPSAnZXhlY3V0ZS1hcGknO1xuICAgIH0gZWxzZSBpZiAoaG9zdG5hbWUuc3RhcnRzV2l0aCgnZGF0YS5qb2JzLmlvdC4nKSkge1xuICAgICAgc2VydmljZSA9ICdpb3Qtam9icy1kYXRhJztcbiAgICB9IGVsc2Uge1xuICAgICAgc2VydmljZSA9IHBhdGhuYW1lID09PSAnL21xdHQnID8gJ2lvdGRldmljZWdhdGV3YXknIDogJ2lvdGRhdGEnO1xuICAgIH1cbiAgfSBlbHNlIGlmIChzZXJ2aWNlID09PSAnYXV0b3NjYWxpbmcnKSB7XG4gICAgY29uc3QgdGFyZ2V0UHJlZml4ID0gKGhlYWRlcnMuZ2V0KCdYLUFtei1UYXJnZXQnKSB8fCAnJykuc3BsaXQoJy4nKVswXTtcbiAgICBpZiAodGFyZ2V0UHJlZml4ID09PSAnQW55U2NhbGVGcm9udGVuZFNlcnZpY2UnKSB7XG4gICAgICBzZXJ2aWNlID0gJ2FwcGxpY2F0aW9uLWF1dG9zY2FsaW5nJztcbiAgICB9IGVsc2UgaWYgKHRhcmdldFByZWZpeCA9PT0gJ0FueVNjYWxlU2NhbGluZ1BsYW5uZXJGcm9udGVuZFNlcnZpY2UnKSB7XG4gICAgICBzZXJ2aWNlID0gJ2F1dG9zY2FsaW5nLXBsYW5zJztcbiAgICB9XG4gIH0gZWxzZSBpZiAocmVnaW9uID09IG51bGwgJiYgc2VydmljZS5zdGFydHNXaXRoKCdzMy0nKSkge1xuICAgIHJlZ2lvbiA9IHNlcnZpY2Uuc2xpY2UoMykucmVwbGFjZSgvXmZpcHMtfF5leHRlcm5hbC0xLywgJycpO1xuICAgIHNlcnZpY2UgPSAnczMnO1xuICB9IGVsc2UgaWYgKHNlcnZpY2UuZW5kc1dpdGgoJy1maXBzJykpIHtcbiAgICBzZXJ2aWNlID0gc2VydmljZS5zbGljZSgwLCAtNSk7XG4gIH0gZWxzZSBpZiAocmVnaW9uICYmIC8tXFxkJC8udGVzdChzZXJ2aWNlKSAmJiAhLy1cXGQkLy50ZXN0KHJlZ2lvbikpIHtcbltzZXJ2aWNlLCByZWdpb25dID0gW3JlZ2lvbiwgc2VydmljZV07XG4gIH1cbiAgcmV0dXJuIFtIT1NUX1NFUlZJQ0VTW3NlcnZpY2VdIHx8IHNlcnZpY2UsIHJlZ2lvbiB8fCAnJ11cbn1cblxuZXhwb3J0IHsgQXdzQ2xpZW50LCBBd3NWNFNpZ25lciB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/aws4fetch/dist/aws4fetch.esm.mjs\n");

/***/ })

};
;